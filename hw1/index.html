<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Kevin Frans</div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		Rasterizing the triangle works by doing a double for loop over the bounding box of the triangle. Then, for each pixel, we check if the pixel is inside the triangle by using the three line test and ensuring that the point is on the same side of all three edges. If so, we fill the pixel with the color of the triangle.

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		To implement supersampling, I first created the sample_buffer to be N times as large as the framebuffer along each dimension. This sample_buffer will hold the supersampled values. During the rasterization code, each line and point just writes to all NxN subpixels within the original pixel. For triangles, we use the same logic as before. Then, we average the sample_buffer across the NxN local neighborhood to get the final color.

		<h2>Task 3: Transforms</h2>
		To get the transformation working, we just had to fill out the corresponding homoegenous-coordinate matrixes. For scale, it is the identity matrix with a scale factor on the diagonal. For translation, the rotation component is the identity matrix and the translation component uses the homogenous coordinate. For rotation, we can put the typical 2D cos/sin rotation matrix in the rotation component, and keep the homogenous coordinate unused.

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates are a way to set the value at a point in a triangle as a weighted average of the values at the vertices. The weighted average always sums to 1. For example, if we have a triangle with the RGB colors at each of the vertices, then we can use barycentric coordinates to create a triangle with a color that smoothly interpolates between each vertex main color.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		To render textures, we first take each triangle and loop over the samples as usual. At each point, we compute the barycentric coordinates and use them to interpolate the per-vertex texture coordinates (which are in 2D). This gives each point a coorespoinding UV texture coordinate. To get the actual pixel, we can use either nearest neighbor (which rounds to the nearest int), or a bilinear interpolation which uses an interpolation between the four nearest texture values.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Level sampling is a way to automatically sample low or high resolutions of a texture, based on how stretched that texture will be by rendered. As an example, if a camera is looking very closely at a texture, we should use the high resolution version so it shows up clearly. But for an object that is far away, we can get away with using a lower resolution texture. To determine this resolution, we can use a trick where we compute the gradient (wrt pixel coordinates) of the texture coordinates -- if the gradient is large, we should use a lower resolution texture, and if the gradient is small, we should use a higher resolution texture.

		In terms of texture pixel sampling, if we use nearest neighbor we get the fastest rendering speed but there could be pixelaed artifacts. If we use bilinear interpolation, we get a smoother result but it is slower. Either way both techniques can use the same memory since we can average the pixel samples live.

		For level sampling, we need to compute separate textures for each resolution which takes more memory, but otherwise the speed should be the same, and we can get a higher quality resolution on high-detail objects.

		For direct supersampling, it is almost more expensive to supersample since we need to iterate over each subpixel. This also costs more memory, since in our implementation we create a new higher-resolution framebuffer. This helps in terms of sharpness for things like edges, where it is important to average out the subpixel samples.
	</body>
</html>